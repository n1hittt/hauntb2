repeat wait() until game:IsLoaded()

local whitelistedHWIDs = {
    "648A21D7-9362-4048-B302-3DBBBEF4D1D7",
    "247AC5B2-EF87-4AF2-8CC0-A2A3BAED177D",
    "A814283D-F0ED-417D-9098-4E1A76FA01A3",
    "C6AO3DCC-213E-46C5-A74F-C9FCACA30057",
    "hwid5 ig"
}

local function getHWID()
    return game:GetService("RbxAnalyticsService"):GetClientId()
end

local hwid = getHWID()
local isWhitelisted = false

for _, v in ipairs(whitelistedHWIDs) do
    if hwid == v then
        isWhitelisted = true
        break
    end
end

if not isWhitelisted then
    game.Players.LocalPlayer:Kick("Your HWID is not whitelisted.")
    return
end

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

Drawing = Drawing
mousemoverel = mousemoverel

local CoreGui = game:GetService("CoreGui")

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local StarterGui = game:GetService("StarterGui")
local Stats = game:GetService("Stats")

local TargetPlr, CamlockPlr
local LocalPlr = Players.LocalPlayer

local TargBindEnabled, CamBindEnabled = false, false

local TargResolvePos

local Connections = {}

local TargHighlight = Instance.new("Highlight", CoreGui)

local CamHighlight = Instance.new("Highlight", CoreGui)
local CamTracerLine = Drawing.new("Line")
CamTracerLine.Thickness = 2

local StrafeSpeed = 0

local TargetAimbot = {
    Enabled = false, 
    Keybind = Enum.KeyCode.E, -- Default keybind set to E

    Prediction = nil, 
    RealPrediction = nil, 

    Resolver = false, 
    ResolverType = "Recalculate", 

    JumpOffset = 0, 
    RealJumpOffset = nil, 

    HitParts = {"HumanoidRootPart"}, 
    RealHitPart = "HumanoidRootPart", 

    LookAt = false, 
    ViewAt = false, 

    Tracer = false, 

    Highlight = false, 
    Stats = false, 

    UseFov = false
}

local CameraAimbot = {
    Enabled = false, 
    Keybind = nil, 

    Prediction = nil, 
    RealPrediction = nil, 

    Resolver = false, 
    ResolverType = "Recalculate", 

    JumpOffset = 0, 
    RealJumpOffset = nil, 

    HitPart = "HumanoidRootPart", 
    RealHitPart = nil, 

    UseAirPart = false, 
    AirPart = "LowerTorso", 
    AirCheckType = "Once in Air", 

    AutoPred = false, 

    Notify = false, 

    Tracer = false, 
    Highlight = false, 

    AimMethod = "Camera", 

    Smoothing = false, 
    Smoothness = nil, 

    UseFov = false
}

local TargetStrafe = {
    Enabled = false, 

    Speed = 1, 
    Distance = 1, 
    Height = 1
}

local Movement = {
    SpeedEnabled = false,
    SpeedAmount = 1,
    Keybind = Enum.KeyCode.V -- Default keybind set to V
}

local function ClosestPlr(Part, UseFov)
    local Distance, Closest = math.huge, nil

    for I, Target in pairs(Players:GetPlayers()) do
        if Target ~= LocalPlr and Target.Character and Target.Character:FindFirstChild(Part) then
            local Position = Workspace.CurrentCamera:WorldToViewportPoint(Target.Character[Part].Position)
            local Magnitude = (Vector2.new(Position.X, Position.Y) - UserInputService:GetMouseLocation()).Magnitude

            if Magnitude < Distance then
                Closest = Target
                Distance = Magnitude
            end
        end
    end

    return Closest
end

local function Resolver(Target, Aimbot)
    local Part = Target.Character[Aimbot.RealHitPart]

    local CurrentPosition = Part.Position
    local CurrentTime = tick()

    wait()

    local NewPosition = Part.Position
    local NewTime = tick()
    local DistanceTraveled = (NewPosition - CurrentPosition)
    local TimeInterval = NewTime - CurrentTime
    local Velocity = DistanceTraveled / TimeInterval

    CurrentPosition = NewPosition
    CurrentTime = NewTime

    if Aimbot.ResolverType == "MoveDirection" then
        return Target.Character.Humanoid.MoveDirection * Target.Character.Humanoid.WalkSpeed
    end

    return Velocity
end

local function AimRedirect()
    if TargetAimbot.Enabled and TargBindEnabled then
        if game.PlaceId == 2788229376 or game.PlaceId == 7213786345 or game.PlaceId == 16033173781 then
            if TargetAimbot.Resolver then
                ReplicatedStorage.MainEvent:FireServer("UpdateMousePosI", TargetPlr.Character[TargetAimbot.RealHitPart].Position + Vector3.new(0, TargetAimbot.RealJumpOffset, 0) + (TargResolvePos * TargetAimbot.RealPrediction))
            else
                ReplicatedStorage.MainEvent:FireServer("UpdateMousePosI", TargetPlr.Character[TargetAimbot.RealHitPart].Position + Vector3.new(0, TargetAimbot.RealJumpOffset, 0) + (TargetPlr.Character[TargetAimbot.RealHitPart].AssemblyLinearVelocity * TargetAimbot.RealPrediction))
            end
        else
            if TargetAimbot.Resolver then
                ReplicatedStorage.MainEvent:FireServer("UpdateMousePosI", TargetPlr.Character[TargetAimbot.RealHitPart].Position + Vector3.new(0, TargetAimbot.RealJumpOffset, 0) + (TargResolvePos * TargetAimbot.RealPrediction))
            else
                ReplicatedStorage.MainEvent:FireServer("UpdateMousePosI", TargetPlr.Character[TargetAimbot.RealHitPart].Position + Vector3.new(0, TargetAimbot.RealJumpOffset, 0) + (TargetPlr.Character[TargetAimbot.RealHitPart].AssemblyLinearVelocity * TargetAimbot.RealPrediction))
            end
        end
    end
end

local function SpectatePlayer(Target)
    if Target and Target.Character then
        Workspace.CurrentCamera.CameraSubject = Target.Character:FindFirstChildOfClass("Humanoid")
    end
end

local function StopSpectate()
    Workspace.CurrentCamera.CameraSubject = LocalPlr.Character:FindFirstChildOfClass("Humanoid")
end

local function LookAtTarget()
    if TargetAimbot.LookAt and TargetPlr and TargetPlr.Character and TargetPlr.Character:FindFirstChild("HumanoidRootPart") then
        local playerHRP = LocalPlr.Character and LocalPlr.Character:FindFirstChild("HumanoidRootPart")
        if playerHRP then
            playerHRP.CFrame = CFrame.new(playerHRP.Position, Vector3.new(TargetPlr.Character.HumanoidRootPart.Position.X, playerHRP.Position.Y, TargetPlr.Character.HumanoidRootPart.Position.Z))
        end
    end
end

local Window = Library:CreateWindow({
    Title = 'haunt.lol',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.1
})

local Tabs = {
    targ = Window:AddTab('Combat'),
    move = Window:AddTab('Misc'),
    visual = Window:AddTab('Visuals'),
    ['UI Settings'] = Window:AddTab('Settings'),
}

-- Target Aimbot Left GroupBox Section

local targetsection = Tabs.targ:AddLeftGroupbox('Target Aim')

targetsection:AddToggle('Enabled', {
    Text = 'Enable',
    Default = false, -- Default value (true / false)
    Tooltip = nil, -- Information shown when you hover over the toggle

    Callback = function(Value)
        TargetAimbot.Enabled = Value
    end
})

targetsection:AddLabel('Keybind'):AddKeyPicker('aimbotkeypicker', {
    Default = 'E', -- Default keybind set to E
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Target Aim Keybind',
    NoUI = false,

    Callback = function(Value)
        TargBindEnabled = Value
    end,

    ChangedCallback = function(New)
        TargetAimbot.Keybind = New
    end
})

targetsection:AddSlider('prediction', {
    Text = 'Prediction',
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 5,
    Compact = false,

    Callback = function(Value)
        TargetAimbot.Prediction = Value
        TargetAimbot.RealPrediction = Value
    end
})

targetsection:AddToggle('resolvertog', {
    Text = 'Resolver',
    Default = false, -- Default value (true / false)
    Tooltip = nil, -- Information shown when you hover over the toggle

    Callback = function(Value)
        TargetAimbot.Resolver = Value
    end
})

targetsection:AddSlider('offset', {
    Text = 'Aimbot Offset',
    Default = 0,
    Min = -1,
    Max = 1,
    Rounding = 3,
    Compact = false,

    Callback = function(Value)
        TargetAimbot.JumpOffset = Value
        TargetAimbot.RealJumpOffset = Value
    end
})

targetsection:AddDropdown('hitpart', {
    Values = { 'Head', 'UpperTorso', 'HumanoidRootPart', 'LowerTorso' },
    Default = 'HumanoidRootPart', -- number index of the value / string
    Multi = false, -- true / false, allows multiple choices to be selected

    Text = 'Hitpart',
    Tooltip = nil, -- Information shown when you hover over the dropdown

    Callback = function(Value)
        TargetAimbot.HitParts = {Value}
        TargetAimbot.RealHitPart = Value
    end
})

targetsection:AddToggle('view', {
    Text = 'View Target',
    Default = false, -- Default value (true / false)
    Tooltip = nil, -- Information shown when you hover over the toggle

    Callback = function(Value)
        TargetAimbot.ViewAt = Value
        if Value then
            SpectatePlayer(TargetPlr)
        else
            StopSpectate()
        end
    end
})

targetsection:AddToggle('lookat', {
    Text = 'Look At Target',
    Default = false, -- Default value (true / false)
    Tooltip = nil, -- Information shown when you hover over the toggle

    Callback = function(Value)
        TargetAimbot.LookAt = Value
    end
})

targetsection:AddToggle('highlight', {
    Text = 'Highlight Target',
    Default = false, -- Default value (true / false)
    Tooltip = nil, -- Information shown when you hover over the toggle

    Callback = function(Value)
        TargetAimbot.Highlight = Value
    end
})

targetsection:AddLabel('Fill'):AddColorPicker('HighlightColor', {
    Default = Color3.new(1, 1, 1), -- Bright green
    Title = 'Highlight Color', -- Optional. Allows you to have a custom color picker title (when you open it)
    Transparency = 0, -- Optional. Enables transparency changing for this color picker (leave as nil to disable)

    Callback = function(Value)
        TargHighlight.FillColor = Value
    end
})

targetsection:AddLabel('Outline'):AddColorPicker('HighlightOutline', {
    Default = Color3.new(0, 0, 0), -- Bright green
    Title = 'Highlight Outline Color', -- Optional. Allows you to have a custom color picker title (when you open it)
    Transparency = 0, -- Optional. Enables transparency changing for this color picker (leave as nil to disable)

    Callback = function(Value)
        TargHighlight.OutlineColor = Value
    end
})

-- Targetstrafe leftgroupbox

local targetstrafebox = Tabs.targ:AddLeftGroupbox('Target Strafe')

targetstrafebox:AddToggle('TargetStrafe', {
    Text = 'Enable',
    Default = false, -- Default value (true / false)
    Tooltip = nil, -- Information shown when you hover over the toggle

    Callback = function(Value)
        TargetStrafe.Enabled = Value
    end
})

targetstrafebox:AddSlider('TargetSpeed', {
    Text = 'Speed',
    Default = 1,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        TargetStrafe.Speed = Value
    end
})

targetstrafebox:AddSlider('TargetDistance', {
    Text = 'Distance',
    Default = 1,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        TargetStrafe.Distance = Value
    end
})

targetstrafebox:AddSlider('TargetHeight', {
    Text = 'Height',
    Default = 1,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        TargetStrafe.Height = Value
    end
})

-- CFrame speed

local movementleftbox = Tabs.move:AddLeftGroupbox('Movement')

movementleftbox:AddToggle('CFrameSpeed', {
    Text = 'CFrame Speed',
    Default = false, -- Default value (true / false)

    Callback = function(Value)
        
    end
}):AddKeyPicker('cfspdbind', {
    Default = 'V', -- Default keybind set to V
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'CFrame Speed',
    NoUI = false,

    Callback = function(Value)
        Movement.SpeedEnabled = Value
    end,
})

movementleftbox:AddSlider('Speedvalue', {
    Text = 'Speed Value',
    Default = 0,
    Min = 0,
    Max = 5000,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        Movement.SpeedAmount = Value / 1000
    end
})

local random = false

targetstrafebox:AddToggle('RandomStrafe', {
    Text = 'Randomized',
    Default = false,
    Tooltip = nil,

    Callback = function(Value)
        random = Value
        if random then
            spawn(function()
                while random do
                    TargetStrafe.Speed = math.random(10, 20)
                    TargetStrafe.Height = math.random(0, 5) - 2.5
                    TargetStrafe.Distance = math.random(2, 5)
                    wait(0.1)
                end
            end)
        end
    end
})

-- Target Aimbot Hook

do
    for I, Tool in pairs(LocalPlr.Backpack:GetChildren()) do
        if Tool:IsA("Tool") and not Connections[Tool] then
            Connections[Tool] = Tool.Activated:Connect(AimRedirect)
        end
    end

    for I, Tool in pairs(LocalPlr.Character:GetChildren()) do
        if Tool:IsA("Tool") and not Connections[Tool] then
            Connections[Tool] = Tool.Activated:Connect(AimRedirect)
        end
    end

    LocalPlr.Character.ChildAdded:Connect(function(Tool)
        if Tool:IsA("Tool") and not Connections[Tool] then
            Connections[Tool] = Tool.Activated:Connect(AimRedirect)
        end
    end)

    LocalPlr.CharacterAdded:Connect(function(Tool)
        Tool.ChildAdded:Connect(function(Tool)
            if Tool:IsA("Tool") and not Connections[Tool] then
                Connections[Tool] = Tool.Activated:Connect(AimRedirect)
            end
        end)
    end)
end

-- Heartbeat Functions

RunService.Heartbeat:Connect(function()
    if TargetAimbot.Enabled and TargBindEnabled then
        TargResolvePos = Resolver(TargetPlr, TargetAimbot)
    end
end)

RunService.Heartbeat:Connect(function()
    if TargetAimbot.Enabled and TargBindEnabled and TargetAimbot.LookAt then
        LookAtTarget()
    end
end)

RunService.Heartbeat:Connect(function()
    if TargetAimbot.Enabled and TargBindEnabled and TargetStrafe.Enabled then
        StrafeSpeed = StrafeSpeed + TargetStrafe.Speed

        LocalPlr.Character.HumanoidRootPart.CFrame = TargetPlr.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(StrafeSpeed), 0) * CFrame.new(0, TargetStrafe.Height, TargetStrafe.Distance)
    end
end)

RunService.Heartbeat:Connect(function()
    if LocalPlr.character:FindFirstChildOfClass("Tool") and LocalPlr.character:FindFirstChildOfClass("Tool").Activated then
        AimRedirect()
    end
end)

-- Stepped Functions

RunService.Stepped:Connect(function()
    if TargetAimbot.Enabled and TargBindEnabled and TargetPlr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
        TargetAimbot.RealJumpOffset = TargetAimbot.JumpOffset
    else
        TargetAimbot.RealJumpOffset = 0
    end
end)

RunService.Stepped:Connect(function()
    if TargetAimbot.Enabled then
        TargetAimbot.RealHitPart = TargetAimbot.HitParts[math.random(#TargetAimbot.HitParts)]
        wait(0.6)
    end
end)

RunService.RenderStepped:Connect(function()
    if TargetAimbot.Enabled and TargBindEnabled and TargetAimbot.Highlight then
        TargHighlight.Parent = TargetPlr.Character
    else
        TargHighlight.Parent = CoreGui
    end
end)

RunService.Stepped:Connect(function()
    if CameraAimbot.Enabled and CamBindEnabled and CamlockPlr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
        CameraAimbot.RealJumpOffset = CameraAimbot.JumpOffset
    else
        CameraAimbot.RealJumpOffset = 0
    end
end)

RunService.Stepped:Connect(function()
    local AirCheckType

    if CameraAimbot.Enabled and CamBindEnabled and CameraAimbot.UseAirPart then
        if CameraAimbot.AirCheckType == "Once in Air" then
            AirCheckType = CamlockPlr.Character.Humanoid.FloorMaterial == Enum.Material.Air
        else
            AirCheckType = CamlockPlr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall
        end
    end

    if CameraAimbot.Enabled and CamBindEnabled and CameraAimbot.UseAirPart and AirCheckType then
        CameraAimbot.RealHitPart = CameraAimbot.AirPart
    else
        CameraAimbot.RealHitPart = CameraAimbot.HitPart
    end
end)

RunService.RenderStepped:Connect(function()
    if CameraAimbot.Enabled and CamBindEnabled then
        if CameraAimbot.AimMethod == "Camera" then
            if CameraAimbot.Resolver then
                if CameraAimbot.Smoothing then
                    Workspace.CurrentCamera.CFrame = Workspace.CurrentCamera.CFrame:Lerp(CFrame.new(Workspace.CurrentCamera.CFrame.p, CamlockPlr.Character[CameraAimbot.RealHitPart].Position + Vector3.new(0, CameraAimbot.RealJumpOffset, 0) + (Resolver(CamlockPlr, CameraAimbot) * CameraAimbot.RealPrediction)), CameraAimbot.Smoothness, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
                else
                    Workspace.CurrentCamera.CFrame = CFrame.new(Workspace.CurrentCamera.CFrame.p, CamlockPlr.Character[CameraAimbot.RealHitPart].Position + Vector3.new(0, CameraAimbot.RealJumpOffset, 0) + (Resolver(CamlockPlr, CameraAimbot) * CameraAimbot.RealPrediction))
                end
            else
                if CameraAimbot.Smoothing then
                    Workspace.CurrentCamera.CFrame = Workspace.CurrentCamera.CFrame:Lerp(CFrame.new(Workspace.CurrentCamera.CFrame.p, CamlockPlr.Character[CameraAimbot.RealHitPart].Position + Vector3.new(0, CameraAimbot.RealJumpOffset, 0) + (CamlockPlr.Character[CameraAimbot.RealHitPart].AssemblyLinearVelocity * CameraAimbot.RealPrediction)), CameraAimbot.Smoothness, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
                else
                    Workspace.CurrentCamera.CFrame = CFrame.new(Workspace.CurrentCamera.CFrame.p, CamlockPlr.Character[CameraAimbot.RealHitPart].Position + Vector3.new(0, CameraAimbot.RealJumpOffset, 0) + (CamlockPlr.Character[CameraAimbot.RealHitPart].AssemblyLinearVelocity * CameraAimbot.RealPrediction))
                end
            end
        else
            local Position

            if CameraAimbot.Resolver then
                Position = Workspace.CurrentCamera:WorldToViewportPoint(CamlockPlr.Character[CameraAimbot.RealHitPart].Position + Vector3.new(0, CameraAimbot.RealJumpOffset, 0) + (Resolver(CamlockPlr, CameraAimbot) * CameraAimbot.RealPrediction))
            else
                Position = Workspace.CurrentCamera:WorldToViewportPoint(CamlockPlr.Character[CameraAimbot.RealHitPart].Position + Vector3.new(0, CameraAimbot.RealJumpOffset, 0) + (CamlockPlr.Character[CameraAimbot.RealHitPart].AssemblyLinearVelocity * CameraAimbot.RealPrediction))
            end

            if CameraAimbot.Smoothing then
                mousemoverel((Position.X - UserInputService:GetMouseLocation().X) * CameraAimbot.Smoothness, (Position.Y - UserInputService:GetMouseLocation().Y) * CameraAimbot.Smoothness)
            else
                mousemoverel(Position.X - UserInputService:GetMouseLocation().X, Position.Y - UserInputService:GetMouseLocation().Y)
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if CameraAimbot.Enabled and CamBindEnabled and CameraAimbot.AutoPred then
        CameraAimbot.RealPrediction = math.round(Stats.Network.ServerStatsItem["Data Ping"]:GetValue()) / 200 * 0.1 + 0.1
    else
        CameraAimbot.RealPrediction = CameraAimbot.Prediction
    end
end)

RunService.RenderStepped:Connect(function()
    if CameraAimbot.Enabled and CamBindEnabled and CameraAimbot.KoCheck and (CamlockPlr.Character.Humanoid.Health <= 2.15 or LocalPlr.Character.Humanoid.Health <= 2.15) then
        CamBindEnabled = false
    end
end)

RunService.RenderStepped:Connect(function()
    local Position, OnScreen

    if CameraAimbot.Enabled and CamBindEnabled and CameraAimbot.Tracer then
        if CameraAimbot.Resolver then
            Position, OnScreen = Workspace.CurrentCamera:WorldToViewportPoint(CamlockPlr.Character[CameraAimbot.RealHitPart].Position + Vector3.new(0, CameraAimbot.RealJumpOffset, 0) + (Resolver(CamlockPlr, CameraAimbot) * CameraAimbot.RealPrediction))
        else
            Position, OnScreen = Workspace.CurrentCamera:WorldToViewportPoint(CamlockPlr.Character[CameraAimbot.RealHitPart].Position + Vector3.new(0, CameraAimbot.RealJumpOffset, 0) + (CamlockPlr.Character[CameraAimbot.RealHitPart].AssemblyLinearVelocity * CameraAimbot.RealPrediction))
        end
    end

    if CameraAimbot.Enabled and CamBindEnabled and CameraAimbot.Tracer and OnScreen then
        CamTracerLine.Visible = true
        CamTracerLine.From = UserInputService:GetMouseLocation()
        CamTracerLine.To = Vector2.new(Position.X, Position.Y)
    else
        CamTracerLine.Visible = false
    end
end)

RunService.RenderStepped:Connect(function()
    if CameraAimbot.Enabled and CamBindEnabled and CameraAimbot.Highlight then
        CamHighlight.Parent = CamlockPlr.Character
    else
        CamHighlight.Parent = CoreGui
    end
end)

RunService.Stepped:Connect(function()
    if Movement.SpeedEnabled then
        LocalPlr.Character.HumanoidRootPart.CFrame = LocalPlr.Character.HumanoidRootPart.CFrame + LocalPlr.Character.Humanoid.MoveDirection * Movement.SpeedAmount
    end
end)

-- InputBegan Functions

UserInputService.InputBegan:Connect(function(Key)
    if TargetAimbot.Enabled and Key.KeyCode == TargetAimbot.Keybind and not UserInputService:GetFocusedTextBox() then
        TargetPlr = ClosestPlr(TargetAimbot.RealHitPart, TargetAimbot.UseFov)
        local Position, OnScreen = Workspace.CurrentCamera:WorldToViewportPoint(TargetPlr.Character[TargetAimbot.RealHitPart].Position)

        if TargBindEnabled then
            TargBindEnabled = false

            if TargetAimbot.Notify then
                StarterGui:SetCore("SendNotification", {
                    Title = "haunt.lol", 
                    Text = "UnLocked: " .. TargetPlr.DisplayName, 
                    Duration = 2.5
                })
            end
            if TargetAimbot.ViewAt then
                StopSpectate()
            end
        else
            if OnScreen then
                TargBindEnabled = true
                TargetPlr = ClosestPlr(TargetAimbot.RealHitPart, TargetAimbot.UseFov)

                if TargetAimbot.Notify then
                    StarterGui:SetCore("SendNotification", {
                        Title = "haunt.lol", 
                        Text = "Locked: " .. TargetPlr.DisplayName, 
                        Duration = 2.5
                    })
                end
                if TargetAimbot.ViewAt then
                    SpectatePlayer(TargetPlr)
                end
            end
        end
    end
end)

UserInputService.InputBegan:Connect(function(Key)
    if CameraAimbot.Enabled and Key.KeyCode == CameraAimbot.Keybind and not UserInputService:GetFocusedTextBox() then
        local Position, OnScreen = Workspace.CurrentCamera:WorldToViewportPoint(ClosestPlr(CameraAimbot.RealHitPart, CameraAimbot.UseFov).Character[CameraAimbot.RealHitPart].Position)

        if CamBindEnabled then
            CamBindEnabled = false

            if CameraAimbot.Notify then
                StarterGui:SetCore("SendNotification", {
                    Title = "haunt.lol", 
                    Text = "UnLocked: " .. CamlockPlr.DisplayName, 
                    Duration = 2.5
                })
            end
        else
            if OnScreen then
                CamBindEnabled = true
                CamlockPlr = ClosestPlr(CameraAimbot.RealHitPart, CameraAimbot.UseFov)

                if CameraAimbot.Notify then
                    StarterGui:SetCore("SendNotification", {
                        Title = "haunt.lol", 
                        Text = "Locking: " .. CamlockPlr.DisplayName, 
                        Duration = 2.5
                    })
                end
            end
        end
    end
end)

-- Removed watermark and keybinds
Library.KeybindFrame.Visible = false

Library:OnUnload(function()
    print('Unloaded')
    Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'Insert', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

ThemeManager:SetFolder('haunt')
SaveManager:SetFolder('haunt')

SaveManager:BuildConfigSection(Tabs['UI Settings'])

ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()
